Optimal Aggregation Algorithms for Middleware Assume that each object in a database has m grades, or scores, one for each of m attributes. ForexamzUan  object can ave a color grade, t at tells ow red it is, and a s ape grade, t at tells ow round it is. For eac attribute, t ere is a sorted list, w ic lists eac object and its grade under t at attribute, sorted by grade ( ig est grade first). Eac object is assigned an overall grade, t at is obtained  bycom`-T  ng t e attribute grades using a  fixedm  notone aggregation function,orcombining rule, suc as mh or average. To determ`h  t e top k objects, t at is, k objects wit t e ig est overall grades, t e naive  algoritm mor  access every object in t e database, to find its grade under eac attribute. Fagin as given an  algoritm  ("Fagin's Algorit mit or FA) t at is mh mh` efficient. For som mm'T` e aggregation functions, FA isoptim  al wit ig probability in t e worst case. We analyze an elegant andrem'-`-  lysim  ple  algoritm  ("t e t res old  algoritm  ", or TA) t at  isoptim  al in am` stronger sense t an FA. We s ow t at TA is essentiallyoptim  al, not just for som mmT-k' aggregation functions, but for all of tem and not just in a ig-probability worst-case sense, but over every database. Unlike FA, w ic requires large buffers (w ose sizemz  grow unboundedly as t e database size grows), TA requires only asmkzz constant-size buffer. TA allows early stopping, w ic yields, in a precise sense,  anapproxim  ate version of t e top k answers. We distinguis two types of access: sorted access (w ere t em`U'  ewaresystem  obtains t e grade of an object insom sorted list by proceeding t roug t e list  sequentiallyfrom  t e top), and  random  access (w ere t e  mzUETh. resystem  requests t e grade of object in a list, and obtains it in one step). We consider t e scenarios w ere  ra...
